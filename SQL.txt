SELECT

    SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY

    DISTINCT
    
    select distinct vend_id from Products;
        Заставляет СУБД вернуть только записи с отличающимися значениями vend_id.
        
    TOP
        SELECT TOP 5 prod_name FROM Products;        
        Извлечь 5 первых записей из таблицы Products;
        
        SELECT TOP (1) PERCENT orderid, orderdate, custid, empid FROM Sales.Orders ORDER BY orderdate DESC;
            Число возвращаемых столбцов вычисляется в процентах.
    
    ORDER BY
        SELECT prod_name FROM Products ORDER BY prod_name;
        
        ORDER BY заставляет СУБД отсортировать данные в алфавитном порядке по указанному столбцу.
        ORDER BY должен быть последним в инструкции SELECT.
        Данные могут сортироваться и по столбцу, который не извлекается в самом запросе.
        При наличии WHERE должен следовать после него.
        
        DESC (DESCENDING) - указать сортировку в обратном порядке.
            SELECT prod_id, prod_price, prod_name FROM Produxts ORDER BY prod_price DESC;
            
            При сортировке по нескольким столбцам DESC применяется только к тому столбцу, после которого оно стоит в запросе:
            SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC, prod_name;
        
        ASC (ASCENDING) - сортировка по возрастанию. Используется по умолчанию.
    
    WHERE   
        Указатель критерия отбора. Указывается сразу после названия таблицы:
        SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49;
        
        Условные операторы:
            =   Равенство
            <>  Неравенство
            !=  Неравенство
            <   Меньше
            <=  Меньше или равно
            !<  Не меньше
            >   Больше
            >=  Больше или равно
            !>  Не больше
            BETWEEN     Вхождение в диапазон
                SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10;
            IS NULL     Значение NULL
            
        AND - для фильтрации данных по нескольким столбцам и добавление условий в предложение WHERE
            SELECT prod_id, prod_price, prod_name FROM Products WHERE vend_id = 'DLL01' AND prod_price <= 4;
        
        OR - заставляет СУБД извлекать только те строки, которые удовлетворяют хотя бы одному условию. В большинстве СУБД второе условие даже не рассматривается, если выполняется первое.
            SELECT prod_name, prod_price FROM Products WHERE vend_id = 'DLL01' OR vend_id = 'BRS01';
        
        Порядок обработки операторов:
            SQL вначале обрабатывает логические операторы AND, а потом OR.
            Для корректной обработки запросов требуется использовать скобки:
                SELECT prod_name, prod_price FROM Products WHERE (vend_id = 'DLL01' OR vend_id = 'BRS01') AND prod_price >=10;
        
        IN - ключевое слово для указания списка значений, обрабатываемых так же, как это делается в случае применения оператора OR.
            SELECT prod_name, prod_price FROM Products WHERE vend_id IN ('DLL01', 'BRS01') ORDER BY prod_name;
        
        NOT - ключевое слово для отрицания какого-либо условия.
            SELECT prod_name FROM Products WHERE NOT vend_id = 'DLL01' ORDER BY prod_name;
            
    GROUP BY
        
        Заставляет СУБД сначала группировать данные, а затем выполнять вычисления по каждой группе.
        
        SELECT vend_id, COUNT(*) AS num_prods FROM Products GROUP BY vend_id;
        
        Правила:
            - В преложениях GROUP BY можно указывать произвольное число столбцов. Это позволяет вкладывать группы одна в другую, благодаря чему обеспечивается тщательный контроль над тем, какие данные подлежать группировке.
            - Если в предложении GROUP BY используются вложенные группы, данные подытоживаются для последней указанной группы.
            - Каждый столбец, указанный в предложении GROUP BY должен быть извлекаемым столбцом или выражением (не итоговой функцией). Если в SELECT используется какое-то выражение, то же самое выражение должно юыть указано в предложении GROUP BY. Псевдонимы применять нельзя.
            - В большинстве реализаций SQL нельзя указывать в предложении GROUP BY столбцы, в которых содержаться данные переменной длины (например текстовые поля или поля комментариев).
            - За исключением инструкций, связанных с итоговыми вычислениями, каждый столбец, упомянутый в инструкции SELECT, должен быть представлен в предложении GROUP BY.
            - Если столбец, по которому выполняется группировка, содержит строку со значением NULL, оно будет трактоваться как отдельная группа. Если имеется несколько строк со значениями NULL, они будут сгруппированы вместе.
            - Предложение GROUP BY должно стоять после предложения WHERE и перед предложением ORDER BY.
            
            Поддерживается необязательное ключевое слово ALL. Его можно применять для извлечения всех групп, даже тех, которые не имеют соответствующих строк.
    
        HAVING
            
            Работает аналогично WHERE, но в отличии от него фильтрует группы, а не строки. Поддерживает все операторы предложения WHERE.
            
            SELECT cust_id, COUNT(*) AS orders FROM Orders GROUP BY cust_id HAVING COUNT(*) >= 2;
            
            SELECT vend_id, COUNT(*) AS num_prods FROM Products WHERE prod_price >= 4 GROUP BY vend_id HAVING COUNT(*) >= 2;
                Получить количество всех поставщиков, предлагающих не менее двух товаров по цене от 4 долларов включительно.
        
        С GROUP BY всегда нужно использовать ORDER BY. Это гарантирует правильную сортировку данных.
        
            SELECT order_num, COUNT(*) AS items
            FROM OrderItems
            GROUP BY order_num
            HAVING COUNT(*) >= 3
            ORDER BY items, order_num;

WITH
    Определяет обобщенное табличное выражение.
    
    Синтаксис: 
        WITH [(column_name [, ... n])]
        AS (CTE_query_definition)
    
    
    После ОТВ должен идти одиночный запрос SELECT, INSERT, UPDATE, MERGE или DELETE.
    
    WITH ProductsCTE (prod_id, prod_name, prod_price)
    AS (SELECT prod_id, prod_name, prod_price FROM Products)
    SELECT * FROM ProductsCTE;
    
OVER
    инструкция, которая определяет окно для применения оконной функции.
    
    Оконная функция - это функция, которая соответственно работает с окном, т.е. набором строк, и возвращает значение на основе неких вычислений.
    
    Синтаксис:
        Оконная функция (столбец для вычислений) OVER (
            [PARTITION BY стобец для группировки]
            [ORDER BY столбец для сортировки]
            [ROWS или RANGE выражение для ограничения строк в пределах группы]
        )
    
    SELECT ProductId, ProductName, CategoryId, Price,
    SUM(Price) OVER (PARTITION BY CategoryId) AS [SUM],
    AVG(Price) OVER (PARTITION BY CategoryId) AS [AVG]
    FROM TestTable;
        
        Для ограничения строк можно использовать:
            - ROWS - ограничивает строки (вместе с ORDER BY);
            - RANGE - логически ограничивает строки за счет указания диапазона значений в отношении к значению текущей строки (вместе с ORDER BY);
            - UNBOUNDED PRECEDING — указывает, что окно начинается с первой строки группы. Данная инструкция используется только как  начальная точка окна;
            - UNBOUNDED FOLLOWING – с помощью данной инструкции можно указать, что окно заканчивается на последней строке группы, соответственно, она может быть указана только как конечная точка окна;
            - CURRENT ROW – инструкция указывает, что окно начинается или заканчивается на текущей строке, она может быть задана как начальная или как конечная точка;
            - BETWEEN «граница окна» AND «граница окна» — указывает нижнюю и верхнюю границу окна, при этом верхняя граница не может быть меньше нижней границы;
            - «Значение» PRECEDING – определяет число строк перед текущей строкой. Эта инструкция не допускается в предложении RANGE;
            - «Значение» FOLLOWING — определяет число строк после текущей строки. Если FOLLOWING используется как начальная точка окна, то конечная точка должна быть также указана с помощью FOLLOWING. Эта инструкция не допускается в предложении RANGE.
    
    Агрегатные оконные функции
        Это функции, которые выполняют на наборе данных вычисления и возвращают итоговое значение.
        
        SUM - сумма в столбце
        AVG - среднее значение в столбце
        MAX - макимальное значение в столбце
        MIN - минимальное значение в столбце
        COUNT - вычисляет количество значений в столбце. Значение NULL не учитываются. (COUNT(*) учитывает и NULL)
        COUNT_BIG - то же что и COUNT, только возвращает BIGINT
    
    Ранжирующие оконные функции
        Ранжируют значение для каждой строки в группе.
        
        ROW_NUMBER - возвращает номер строки
        RANK - возвращает ранг каждой сроки
        DENSE_RANK - возвращает ранг каждой строки. В отличии от RANK, для одинаковых значений возвращает ранг, не пропуская следующий (в случае одинаковых значений).
        NTILE - возвращает рещультирующий набор, разделенный на группы по определенному столбцу.
        
        SELECT ProductId, ProductName, CategoryId, Price,
        ROW_NUMBER() OVER (PARTITION BY CategoryId ORDER BY ProductId) AS [ROW NUMBER],
        RANK() OVER (PARTITION BY CategoryId ORDER BY Price) AS [RANK]
        FROM TestTable
        ORDER BY ProductId;
         
    Функции смещения
        SELECT ProductId, ProductName, CategoryId, Price,
        LEAD(ProductId) OVER (PARTITION BY CategoryId ORDER BY ProductId) AS [LEAD],
        LAG(ProductId) OVER (PARTITION BY CategoryId ORDER BY ProductId) AS [LAG],
        FIRST_VALUE(ProductId) OVER (PARTITION BY CategoryId ORDER BY ProductId 
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS [FIRST_VALUE],
        LAST_VALUE(ProductId) OVER (PARTITION BY CategoryId
            ORDER BY ProductId ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS [LAST_VALUE],
        LEAD(ProductId, 2) OVER (PARTITION BY CategoryId ORDER BY ProductId) AS [LEAD_2],
        LAG(ProductId, 2, 0) OVER (PARTITION BY CategoryId ORDER BY ProductId) AS [LAG_2]
        FROM TestTable
        ORDER BY ProductId;

JOIN
    
    Принимает на вход две таблицы. Выполняет операции трех видос соединения: перекрестного, внутреннего и внешнего.
    
    Перекрестное включает только декартово произведение.
        
        Это простейший вид оператора JOIN.
        
        SELECT C.custid, E.empid
        FROM Sales.Customers AS C
            CROSS JOIN HR.Employees AS E;
        
        Перекрестное самосоединение
        
            SELECT 
            E1.empid, E1.firstname, E1.lastname,
            E2.empid, E2.firstname, E2.lastname
            FROM HR.Employees AS E1
                CROSS JOIN HR.Employees AS E2;
    
    Внуреннее состоит из декартового произведения и фильтраций.
        
        Подразумевает наличие между именами таблиц ключевого слова INNER JOIN. INNER можео опустить, т.к. любое соединени по умолчанию является внутренним.
        Чтобы указать предикат, который будет фильтровать строки использовать инструкцию ON.
        
        SELECT E.empid, E.firstname, E.lastname, O.orderid
        FROM HR.Employees AS E
            JOIN Sales.Orders AS O
                ON E.empid = O.empid;
    
    Внешние соединения
        
        В дополнение к внутреннему добавляет внешние строки.
        
        Синтаксис:
            Ключевое слово JOIN находится между именами таблиц, а условие обозначается инструкцией ON.
            Используются ключевые слова:
                LEFT OUTER JOIN
                RIGHT OUTER JOIN
                FULL OUTER JOIN
            
            Слово OUTER является не обязательным.
            LEFT, RIGHT означают, что в результат попадают строки из левой / правой таблиц. FULL используется для сохранения строк с обеих сторон.
            Всем атрибутам, с противоположной стороны, для которых не нашлось соответствия, устанавливается значение NULL.
            
        Зарос соединяет таблицы Customers и Orders:
            SELECT C.custid, C.companyname, O.orderid
            FROM Sales.Customers AS C
                LEFT OUTER JOIN Sales.Orders AS O
                    ON C.custid = O.custid;
            
            Это левое внешнее соединение.
    
    Множественные внешние соединения
        
        
    
    Составные соединения
        Это соединение, предикат которого содержит больше одного атрибута с каждой стороны. Обычно использует составное отношение первичного и внешнего ключей.
        
        FROM dbo.Table1 AS T1
            JOIN dbo.Table2 AS T2
                ON T1.col1 = T2.col1
                AND T1.col2 = T2.col2
        
    Множественные соединения
        SELECT C.custid, C.companyname, O.orderid, OD.productid, OD.qty
        FROM Sales.Customers AS C
            JOIN Sales.Orders AS O ON C.custid = O.custid
            JOIN Sales.OrderDetails AS OD ON O.orderid = OD.orderid;
    
    
    
Фильтрация с использованием метасимволов
    Оператор LIKE - сообщает СУБД, что следующий шаблон поиска необходимо анализировать с учетом метасимволов, а не искать точные совпадения.
    
    Метасимволы:
        % - найти все вхождения любого символа.
            SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE 'Fish%'; - найти все товары, названия которых начинаются со слова Fish.
        
        _ - используется как знак %, но при этом учитывается не множетво символов, а только один.
            SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE '__ inch teddy bear';
        
        [] - служит для указания набора символов, каждый из которых должен совпадать с искомым значением, в точно указанном месте (в позиции метасимвола).
            SELECT cust_contact FROM Customers WHERE cust_contact LIKE '[JM]%' ORDER BY cust_contact; - найти всех всех клиентов, имена которых начинаются на буквук J или M.

Конкатенация полей:
    SELECT vend_name + ' (' + vend_country + ')' FROM Vendors ORDER BY vend_name;
        В результате вернется имя, хранящееся в столбце vend_name, строка ' (', название страны, хранящееся в столбце vend_country, строка содержащая ')'.
        
        Чтобы удалить пробелы, дополняемые до ширины столбца, использовать SQL-функцию RTRIM():
            SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')' FROM Vendors ORDER BY vend_name;
        
            RTRIM() обрезает пробелы справа, LTRIM() обрезает пробелы слева, TRIM() обрезает пробелы справа и слева.
   
    Псевдонимы
        Псевдоним - альтернативное имя для поля или значения. Присваиваются с помощью ключевого слова AS.
        
        SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')' AS vend_title FROM Vendors ORDER BY vend_name;
    
    Вычисление математических значений
        SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM OrderItems WHERE order_num = 20008;
        
        В SQL поддердиваются основные математические операторы.

Функции обработки данных
    Функции для работы с текстом:
        UPPER() - преобразует символы в верхний регистр.
        LEFT() - возвращает символы из левой части строки.
        
Итоговые вычисления:
    COUNT()
        Подсчитывает число строк.
        COUNT(*) - для подсчета строк в таблице, независимо от того, сожержат столбцы значения NULL или нет;
        COUNT(столбец) - для подсчета числа строк, которые имеют значения в указанных столбцах, значения NULL игнорируются.

Подзапросы
    
    SELECT cust_name, cust_contact FROM Customers
    WHERE cust_id IN (
        SELECT cust_id FROM Orders WHERE order_num IN (
            SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01'
        )
    );
    
    SELECT в подзапросах могут возвращать только один столбец.
    
    SELECT cust_name, cust_state,
        (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders
    FROM Customers
    ORDER BY cust_name;


Изменение данных
    
    Добавление данных
        
        Команды:
            INSERT VALUES
            INSERT SELECT
            EXEC SELECT
            SELECT INTO
            BULK INSERT
        
        INSERT VALUES
            Используется для добавления строк, основанных на заданных значениях.
            
            INSERT INTO dbo.Orders(orderid, orderdate, empid, custid) VALUES (10001, '20090212', 3, 'A');
            
            Позволяется указывать через запятую сразу несколько строк:
                INSERT INTO dbo.Orders (orderid, orderdate, empid, custid)
                VALUES
                    (10003, '20090213', 4, 'B'),
                    (10004, '20090214', 1, 'A'),
                    (10005, '20090215', 1, 'C'),
                    (10006, '20090215', 3, 'C');
        
        INSERT SELECT
            Добавляет в таблицу набор строк, полученных в результате выборки.
            
            INSERT INTO dbo.Orders(orderid, orderdate, empid, custid)
            SELECT orderid, orderdate, empid, custid
            FROM Sales.Orders
            WHERE shipcountry = 'Великобритания';
        
        INSERT EXEC
            Для добавления в таблицу строк, возвращаемых хранимыми процедурами или динамическими пакетами.
            
            INSERT INTO dbo.Orders(orderid, orderdate, empid, custid)
                EXEC Sales.usp_getorders @country = 'Франция';
        
        SELECT INTO
            Создает целевую таблицу и заполняет ее результирующим набором, который возвращается запросом. Поддерживается только языком T-SQL.
            Нельзя использовать для добавления данных в уже имеющиеся таблицы.
            
            Синтаксис:
                INTO <имя_целевой_таблицы>
                Должна быть указана непосредственно перед инструкцией FOR того запроса, который генерирует результирующий набор.
                
                Следующий код создает таблицу dbo.Orders и копирует в нее все содержимое таблицы Sales.Orders:
                
                SELECT orderid, orderdate, empid, custid
                INTO dbo.Orders FROM Sales.Orders;
            
            Командой игнорируются: ограничения, индексы, триггеры и разрешения.
    
    Удаление данных
        
        DELETE
            
            Воспринимает только две инструкции: FROM и WHERE.
            
            DELETE FROM dbo.Orders WHERE orderdate < '20070101';
        
        TRUNCATE
            
            Удаляет из таблицы все ее содержимое. Не поддерживает никаких фильтров.
            
            TRUNCATE TABLE dbo.T1;
            
            Работает быстрее DELETE, является полностью транзакционной, можно сделать ROLLBACK.
            Сбрасывает содержимое свойства identity к его исходному состоянию.
            Нельзя применять к таблицам, на которые ссылается внешний ключ.
        
        DELETE с JOIN
            
            Удалить заказы, размещенные американскими клиентами:
            
            DELETE FROM O
            FROM dbo.Orders AS O
                JOIN dbo.Customers AS C
                    ON O.custid = C.custid
            WHERE C.country = N'США';
    
    Обновление данных
        
        UPDATE dbo.OrderDetails
            SET discount = discount + 0.05
        WHERE productid = 51; /* Увеличить скидку для продукта под номером 51 на 5% */
        
        Поддерживаемые операторы:
            +=  с суммированием
            -=  с вычитанием
            *=  с умножением
            /=  с делением
            %=  присваивание по модулю
            
        
        UPDATE с JOIN
        
            Увеличить скидку на 5% для всех заказов, размещенных клиентом под номером 1.
            
            UPDATE OD
                SET discount += 0.05
            FROM dbo.OrderDetails AS OD
                JOIN dbo.Orders AS OD
                    ON OD.orderid = O.orderid
            WHERE O.custid = 1;

Транзакции
    
    Транзакция - некая единица работы, которая может включать различные операции, извлекающие или изменяющие как сами данные, так и их определение.
    
    Можно обозначить явно или неявно.
    
    Для открытия транзакции используется инструкция BEGIN TRAN. Чтобы подтвердить транзакцию нужно указать инструкцию COMMIT TRAN. Что бы отменить транзакцию (не подтверждать выполнение) использовать инструкцию ROLLBACK TRAN.
    
    Пример транзакции:
        BEGIN TRAN;
            INSERT INTO dbo.T1(keycol1, col1, col2) VALUES(4, 101, 'C');
            INSERT INTO dbo.T2(keycol, col1, col2) VALUES(4, 201, 'X');
        COMMIT TRAN;
    
    Каждая отдельная команда считается транзакцией и подтверждается по умолчанию. Для изменения поведения использовать параметр сессии IMPLICIT_TRANSACTIONS, который изначально выключен.
    
    Свойства:
        - атомарность (atomicity)
            Если хоть одна инструкция в транзакции не выполнена, отменяются все выполненые действия в транзакции.
            В SQL Server есть функция @@TRANCOUNT. Если текущий участок кода выполняется внутри транзакции, она возвращает положительное число, в противном случае 0.
        - согласованность (consistensy)
            Обозначает состояние данных, к которым предоставляетя параллельный доступ на чтение и запись. БД должна соблюдать все аспекты целостноси, определенные внутри нее с помощью различных правил (первичные и внешние ключи, ограничения уникальности и т.д.). В результате транзакции база данных меняет одно согласованное состояние на другое.
        - изоляция (isolation)
            Используется для управления доступом к данным. Следит за тем, чтобы транзакция получала доступ только к той информации, которая обладает необходимым уровнем согласованности.
            
            Виды изоляции:
                - традиционный (основан на блокировании)
                - новый (управление версиями строк)
        - надежность (durability)
            Если в журнал транзакций попала инструкция COMMIT TRAN, транзакция считается надежной, при этом нет никакой гарантии, что данный действительно были записаны на диск.
    
    Блокировки и блокирование
    
        Режимы блокировок:
            - монопольный
                Блокировка, которая может быть получена только одной транзакцией. Нельзя получить, если ресурс уже заблокирован.
                Если установлена монопольная блокировка, другие транзакции не смогут выполнить какое-либо блокирование того же ресурса. Действует по умолчанию. Иными словами, строки, редактируемые одной транзакцией, доступны для всех остальных транзакций только в режиме чтения (если выставлен подходящий уровень изоляции).
            - разделяемый
                Открывает доступ к одному и тому же ресурсу одновременно из нескольких транзакций.
        
        Уровни изоляции
            
            Определяют поведение пользователей, которые считывают или записывают данные в один и тот же момент времени. Чтение по умолчанию подразумевает выборку данных с использованием разделяемых блокировок. Запись требует монопольной блокировки.
            
            Способом получения и продолжительностью действия блокировок можно управлять только при чтении.
            
            SQL Server поддерживает четыре традиционных уровня изоляции, основанных на писсиместическом управлении параллелизмом:
                READ UNCOMMITED
                    Самый низкий уровень изоляции. Не требует получения разделяемой блокировки для чтения данных.
                    Исключается конфликт с пользователями, которые производят запись в монопольном режиме (можно сяитывать неподтвержденные данные).
                    Пока чтение проходит на этом уровне, пользователи могут свободно записывать данные.
                READ COMMITED (по умолчанию)
                    Допускает чтение только тех изменений, которые были подтверждены. Для всего остального требуется получить разделяемую блокировку, которая конфликтует с монопольной.
                    Исключает грязное чтение.
                REPEATABLE READ
                    Запрещает изменение данных между операциями чтения, которые проводятся в одной транзакции.
                    Для чтения необходимо получить разделяемую блокировку, которая удерживается до завершения транзакции. Это делает невозможным монопольное блокирование, и как следствие, изменение ресурса.
                SERIALIZABLE
                    Для выполнение операции чтения требуется установление разделяемой блокировки, которая удерживается до конца транзакции.
                    Так же, заставляет клиента, который считывает данные блокировать весь диапазон ключей, соответствующих фильтру запроса. Другими словами, данный режим не дает другим транзакциям добавлять строки, которые могут пройти фильтр запроса.
            
            И еще два уровня оптимистического подхода:
                SHAPSHOT (аналог READ COMMITED)
                    Гарантирует, что клиент, считывающий данные, получит последнюю версию строки, подтвержденную на момент начала транзакции. Это обеспечитвает повторяющееся чтение.
                    
                    Активация:
                        ALTER DATABASE <база_данных> ALLOW_SNAPSHOT_ISOLATION ON;
                    
                    Обнаруживает конфликты, путем анализа БД tempbd;
                    
                READ COMMITED SNAPSHOT (аналог SERIALIZABLE)
                    В отличии от SNAPSHOT предоставляет последний снимок данных, подтвержденный на момент запуска команды, а не транзакции.
                    Не следит за возникновением конфликтов при операции обновления.
                    
                    Активация:
                        ALTER DATABASE <база_данных> ALLOW_SNAPSHOT_ISOLATION ON;
                
                Эти два уровня не предусматривают разделяемых блокировок при чтении, поэтому она не заставляют ждать снятия монопольной блокировки.
                Если в текущем состоянии строка не подходит для чтения, сервер предлагает прочитать ее старую версию.
            
            Распространить уровень изоляции на всю сессию:
                SET TRANSACTION ISOLATION LEVEL <навание уровня изоляции>;
            
            Распространить на текущий запрос:
                SELECT ... FROM <table> WITH (<название_уровня_изоляции>);
            
            Стандартным уронем изоляции является READ COMMITED SNAPSHOT. Основывается на управлении версиями строк (для чтения данных не нужно выполнять разделяемое блокирование).
            
            READ COMMITED не позволяет считывать данные, которые изменяются в рамках другой транзакции.
            Это ПИССИМЕСТИЧЕСКИЙ способ управления параллелизмом.
            
            ОПТИМИСТИЧЕСКИЙ подход: основан на READ COMMITED SNAPSHOT: если транзакция попытается прочитать строки, которые в это самое время подлежат изменению, она получит их последнее подтвержденное состояние, актуальное на момент запуска самой транзакции.
        
        Совместимость блокировок
            
            Это взаимодействие между транзакциями, работающими с одними и теми же данными.
            
            Взаимодействие транзакций на уровне блокировок:
                Данные, которые изменяются одной транзакцией, не могут изменяться или считываться другой, пока первая не будет завершена. Если данные считываются одной транзакцией, они не могут быть изменены другой.
        
        Поддерживающие типы ресурсов: ключи, строковые идентификаторы, страницы, объекты (например таблицы), БД и т.д. а так же экстенты, единицы распределения, кучи и сбалансированные деревья.
        
        
    Взаимные блокировки
        Возникают когда два или больше процессов блокируют друг друга.
        
        DEDLOCK_PRIORITY
            Расставляет процессы приоритетам от -10 до 10 на преждевременное завершение. Если приоритеты равны, решение принимается исходя из того, кто последним проявлял активность.
        
        Как избавиться:
            - Делать транзакции как можно более короткими, вынося за их рамки те операции, которые с логической точки зрения не являются частью единого целого.
            - Обращаться к базам в одном порядке.
            - Выбирать подходящий режим уровня изоляции.
            
Пользовательские функции
    
    Инкапсулируют код, предназначенный для вычисления и возвращения определенного результата, с возможностью использования входящих параметров.
    
    Любую функцию можно разместить внутри запроса, вместо скалярного выражения,  в рамках инструкции FROM.
    
    Не способны  изменять структуру или соддержимое БД.

Хранимые процедуры

    Это набор из нескольких инструкций, сохраненный для последующего выполнения.
    Поддерживают входящие и исходящие параметры, могу твозвращать результирующие наборы и вызывать код, который имеет побочные эффекты.
    
    Преимущества:
        - Инкапсуляция логики. Изменения, которые вносятся в реализацию хранимой процедуры, производятся в одном месте, но доступны для всех ее пользователей.
        - Улучшенное управление безопасностью. Можно выдавать полномочия на выполнение всей процедуры целиком.
        - Возможность обработки ошибок и принятие необходимых мер внутри самой процедуры.
    
    CREATE PROC Sales.GetCustomerOrders
	@custid AS INT,
	@fromdate AS DATETIME = '19000101',
	@todate AS DATETIME = '99991231',
	@numrows AS INT OUTPUT
    AS
    SET NOCOUNT ON;

    SELECT orderid, custid, empid, orderdate
    FROM Sales.Orders
    WHERE custid = @custid
        AND orderdate >= @fromdate
        AND orderdate < @todate;

    SET @numrows = @@rowcount;
    
    Воспользоваться процедурой:
        
        DECLARE @rc AS INT;

        EXEC Sales.GetCustomerOrders
            @custid = 1,
            @fromdate = '20070101',
            @todate = '20080101',
            @numrows = @rc OUTPUT;

            SELECT @rc AS numrows;

Отличия процедур и функций

+---------------------------------+----------------------------------------+
| Stored Procedure (SP)           | Function (UDF - User Defined           |
|                                 | Function)                              |
+---------------------------------+----------------------------------------+
| SP can return zero , single or  | Function must return a single value    |
| multiple values.                | (which may be a scalar or a table).    |
+---------------------------------+----------------------------------------+
| We can use transaction in SP.   | We can't use transaction in UDF.       |
+---------------------------------+----------------------------------------+
| SP can have input/output        | Only input parameter.                  |
| parameter.                      |                                        |
+---------------------------------+----------------------------------------+
| We can call function from SP.   | We can't call SP from function.        |
+---------------------------------+----------------------------------------+
| We can't use SP in SELECT/      | We can use UDF in SELECT/ WHERE/       |
| WHERE/ HAVING statement.        | HAVING statement.                      |
+---------------------------------+----------------------------------------+
| We can use exception handling   | We can't use Try-Catch block in UDF.   |
| using Try-Catch block in SP.    |                                        |
+---------------------------------+----------------------------------------+

Триггеры
    
    Специальный вид хранимых процедур, который нельзя вызвать вручную.
    Срабатывает и запускает свой код в момент, когда происходит определенное событие.
    
    SQL Server поддерживает два вида событий:
        - с операциями DML (например INSERT)
        - с операциями DDL (например CREATE TABLE)
        
        DML-триггеры
            
            Могут срабатывать либо после завершения соответствующего события, либо вместо него.
            Таблицы, изменения в которых приводят к срабатыванию триггера иногда помечают словами inserted или deleted.
            
            Создание триггера:
                CREATE TRIGGER trg_T1_insert_audit ON dbo.T1 AFTER INSERT
                AS
                SET NOCOUNT ON;
                
                INSERT INTO dbo.T1_Audit(keycol, datacol)
                    SELECT keycol, datacol FROM inserted;
                GO
        
        DDL-триггеры
            
            Могут использоваться для таких задач как проверка и управление процессом изменения данных, соблюдение различных правил и т.д.
            Срабатывают только после определенного события.
            
            EVENTDATA
                Позволяет получить информацию внутри триггера о том, как он был вызван.
            
            С помощью выражений XQuery извлекаются разлиыне атрибуты (время возникновения, тип и имя пользователя).
            
            Создание триггера:
                
                CREATE TRIGGER trg_audit-ddl-events
                    ON DATABASE FOR DDL_DATABASE_LEVEL_EVENTS
                AS
                SET NOCOUNT ON;
                
                DECLARE @evendata AS XML = eventdata();
                
                INSERT INTO dbo.AuditDDLEvents (
                    posttime, eventtype,loginname, schemaname, objectname, targetobjectname, eventdata)
                    VALUES(
                        @eventdata.value('(/EVENT_INSTANCE/PostTime) [1]', 'VARCHAR(23)'),
                        @eventdata.value('(/EVENT_INSTANCE/EventType) [1]', 'SYSNAME'),
                        @eventdata.value('(/EVENT_INSTANCE/LoginName) [1]', 'SYSNAME'),
                        @eventdata.value('(/EVENT_INSTANCE/SchemaName)[1]', 'SYSNAME'),
                        @eventdata.value('(/EVENT_INSTANCE/ObjectName)[1]', 'SYSNAME'),
                        @eventdata.value('(/EVENT_INSTANCE/TargetObjectName)[1]', 'SYSNAME'),
                        @eventdata);
                GO
    
    Если триггер сработал по команде из транзакции, то сам триггер тоде будет считаться частью транзакции. Если внутри него вызвать ROLLBACK TRAN то все действия триггера отменятся.
    
Первичные ключи
    
    Это особое ограничение для значений в столбце, чтобы они были уникальными и никогда не изменялись.
    
    Условия:
        - строки не должны иметь одно и то же значение;
        - каждая строка долдна иметь какое-то значение (NOT NULL);
        - столбец первичного ключа не модет быть модифицирован или обновлен;
        - значения первичного ключа не могут быть использованы повторно.
    
    Способы задания:
        
        CREATE TABLE Vendors
        (
            vend_id CHAR(10) NOT NULL PRIMARY KEY,
            vend_name CHAR(50) NOT NULL,
            ...
        );
        
        ALTER TABLE Vendors
        ADD CONSTRAINT PRIMARY KEY(vend_id);

Внешние ключи
    
    Это столбец одной таблицы, значения которого совпадают со значениями столбца, являющегося первичным ключом другой таблицы.
    
    Способы задания:
        
        CREATE TABLE Orders
        (
            order_num INTEGER NOT NULL PRIMARY KEY,
            ...
            cust_id CHAR(10) NOT NULL REFERENCES Customers(cust_id);
        );
        
        ALTER TABLE Orders
        ADD CONSTRAINT
        FOREIGN KEY (cust_id) REFERENCES Customers (cust_id);

Ограничения уникальности (UNIQUE)
    
    Отличия от primary key:
        - таблица может содержать множество ограничений уникальности, но у нее должен быть только один первичный ключ.
        - столбцы UNIQUE могут содержать NULL.
        - столбцы UNIQUE можно модифицировать и обновлять.
        - значения столбцов UNIQUE можно использовать повторно.
        - столбцы UNIQUE не могут быть использованы для определения первичных ключей.

Структура хранения данных таблицы
    
    Данные хранятся в файлах, которые поделены на страницы.
    Каждая страница начинается с 96 байтового заголовка (идентификатор страницы, идентификатор объекта базы данных,  ссылки на предыдущую и последующую страницы, тип страницы, объем свободного места страницы, дли индексных страниц - уровень страницы).
    
    Кучи - таблицы, которые не имеют кластеризованного индекса.
        
        Строки данных не отсортированы.
        Отсутствует порядок в последовательности страниц. Страницы данных не образуют связный список.
    
    Кластеризованные страницы - это таблицы, имеющие кластеризованный индекс.
    
        Некластеризованный индекс:        
            Корневой узел содержит значение ключа и указатель на индексную страницу.        
            Лист дерева содержит индекс ключа, номер файла данных, номер страницы данных, номер записи на странице.
        
        Кластеризованный индекс:
            Означает индекс, объединенный с данными (индекс представляет собой часть таблицы данных).
            
            Уровень листьев этого индекса есть сами страницы таблицы с данными.
            Строки данных хранятся по порядку.
            При создании первичного ключа сервер автоматически создает кластеризованный индекс для этого ключа.
            
            Для таблицы может быть создан только один кластерный индекс.
    
    

Индексы
    
    Предназначены для логической сортировки хранимых данных.
    
    Особенности:
        - повышают чтение и извлечение данных, замедляют дбавление, обновление и удаление строк.
        - требует дополнительного места на диске.
        - в качестве индекса можно определить несколько столбцов.
    
    Создание:
        CREATE INDEX prod_name_ind
        ON Produxts(prod_name);
